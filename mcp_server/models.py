# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T05:09:48+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, RootModel


class BoundingBox(BaseModel):
    height: float = Field(..., description='Height.')
    left: float = Field(..., description='Coordinate of the left boundary.')
    top: float = Field(..., description='Coordinate of the top boundary.')
    width: float = Field(..., description='Width.')


class Code(Enum):
    NoError = 'NoError'
    BadRequest = 'BadRequest'
    BadRequestExceededBatchSize = 'BadRequestExceededBatchSize'
    BadRequestNotSupported = 'BadRequestNotSupported'
    BadRequestInvalidIds = 'BadRequestInvalidIds'
    BadRequestProjectName = 'BadRequestProjectName'
    BadRequestProjectNameNotUnique = 'BadRequestProjectNameNotUnique'
    BadRequestProjectDescription = 'BadRequestProjectDescription'
    BadRequestProjectUnknownDomain = 'BadRequestProjectUnknownDomain'
    BadRequestProjectUnknownClassification = 'BadRequestProjectUnknownClassification'
    BadRequestProjectUnsupportedDomainTypeChange = (
        'BadRequestProjectUnsupportedDomainTypeChange'
    )
    BadRequestProjectUnsupportedExportPlatform = (
        'BadRequestProjectUnsupportedExportPlatform'
    )
    BadRequestProjectImagePreprocessingSettings = (
        'BadRequestProjectImagePreprocessingSettings'
    )
    BadRequestProjectDuplicated = 'BadRequestProjectDuplicated'
    BadRequestIterationName = 'BadRequestIterationName'
    BadRequestIterationNameNotUnique = 'BadRequestIterationNameNotUnique'
    BadRequestIterationDescription = 'BadRequestIterationDescription'
    BadRequestIterationIsNotTrained = 'BadRequestIterationIsNotTrained'
    BadRequestIterationValidationFailed = 'BadRequestIterationValidationFailed'
    BadRequestWorkspaceCannotBeModified = 'BadRequestWorkspaceCannotBeModified'
    BadRequestWorkspaceNotDeletable = 'BadRequestWorkspaceNotDeletable'
    BadRequestTagName = 'BadRequestTagName'
    BadRequestTagNameNotUnique = 'BadRequestTagNameNotUnique'
    BadRequestTagDescription = 'BadRequestTagDescription'
    BadRequestTagType = 'BadRequestTagType'
    BadRequestMultipleNegativeTag = 'BadRequestMultipleNegativeTag'
    BadRequestImageTags = 'BadRequestImageTags'
    BadRequestImageRegions = 'BadRequestImageRegions'
    BadRequestNegativeAndRegularTagOnSameImage = (
        'BadRequestNegativeAndRegularTagOnSameImage'
    )
    BadRequestRequiredParamIsNull = 'BadRequestRequiredParamIsNull'
    BadRequestIterationIsPublished = 'BadRequestIterationIsPublished'
    BadRequestInvalidPublishName = 'BadRequestInvalidPublishName'
    BadRequestInvalidPublishTarget = 'BadRequestInvalidPublishTarget'
    BadRequestUnpublishFailed = 'BadRequestUnpublishFailed'
    BadRequestIterationNotPublished = 'BadRequestIterationNotPublished'
    BadRequestSubscriptionApi = 'BadRequestSubscriptionApi'
    BadRequestExceedProjectLimit = 'BadRequestExceedProjectLimit'
    BadRequestExceedIterationPerProjectLimit = (
        'BadRequestExceedIterationPerProjectLimit'
    )
    BadRequestExceedTagPerProjectLimit = 'BadRequestExceedTagPerProjectLimit'
    BadRequestExceedTagPerImageLimit = 'BadRequestExceedTagPerImageLimit'
    BadRequestExceededQuota = 'BadRequestExceededQuota'
    BadRequestCannotMigrateProjectWithName = 'BadRequestCannotMigrateProjectWithName'
    BadRequestNotLimitedTrial = 'BadRequestNotLimitedTrial'
    BadRequestImageBatch = 'BadRequestImageBatch'
    BadRequestImageStream = 'BadRequestImageStream'
    BadRequestImageUrl = 'BadRequestImageUrl'
    BadRequestImageFormat = 'BadRequestImageFormat'
    BadRequestImageSizeBytes = 'BadRequestImageSizeBytes'
    BadRequestImageExceededCount = 'BadRequestImageExceededCount'
    BadRequestTrainingNotNeeded = 'BadRequestTrainingNotNeeded'
    BadRequestTrainingNotNeededButTrainingPipelineUpdated = (
        'BadRequestTrainingNotNeededButTrainingPipelineUpdated'
    )
    BadRequestTrainingValidationFailed = 'BadRequestTrainingValidationFailed'
    BadRequestClassificationTrainingValidationFailed = (
        'BadRequestClassificationTrainingValidationFailed'
    )
    BadRequestMultiClassClassificationTrainingValidationFailed = (
        'BadRequestMultiClassClassificationTrainingValidationFailed'
    )
    BadRequestMultiLabelClassificationTrainingValidationFailed = (
        'BadRequestMultiLabelClassificationTrainingValidationFailed'
    )
    BadRequestDetectionTrainingValidationFailed = (
        'BadRequestDetectionTrainingValidationFailed'
    )
    BadRequestTrainingAlreadyInProgress = 'BadRequestTrainingAlreadyInProgress'
    BadRequestDetectionTrainingNotAllowNegativeTag = (
        'BadRequestDetectionTrainingNotAllowNegativeTag'
    )
    BadRequestInvalidEmailAddress = 'BadRequestInvalidEmailAddress'
    BadRequestDomainNotSupportedForAdvancedTraining = (
        'BadRequestDomainNotSupportedForAdvancedTraining'
    )
    BadRequestExportPlatformNotSupportedForAdvancedTraining = (
        'BadRequestExportPlatformNotSupportedForAdvancedTraining'
    )
    BadRequestReservedBudgetInHoursNotEnoughForAdvancedTraining = (
        'BadRequestReservedBudgetInHoursNotEnoughForAdvancedTraining'
    )
    BadRequestExportValidationFailed = 'BadRequestExportValidationFailed'
    BadRequestExportAlreadyInProgress = 'BadRequestExportAlreadyInProgress'
    BadRequestPredictionIdsMissing = 'BadRequestPredictionIdsMissing'
    BadRequestPredictionIdsExceededCount = 'BadRequestPredictionIdsExceededCount'
    BadRequestPredictionTagsExceededCount = 'BadRequestPredictionTagsExceededCount'
    BadRequestPredictionResultsExceededCount = (
        'BadRequestPredictionResultsExceededCount'
    )
    BadRequestPredictionInvalidApplicationName = (
        'BadRequestPredictionInvalidApplicationName'
    )
    BadRequestPredictionInvalidQueryParameters = (
        'BadRequestPredictionInvalidQueryParameters'
    )
    BadRequestInvalidImportToken = 'BadRequestInvalidImportToken'
    BadRequestExportWhileTraining = 'BadRequestExportWhileTraining'
    BadRequestInvalid = 'BadRequestInvalid'
    UnsupportedMediaType = 'UnsupportedMediaType'
    Forbidden = 'Forbidden'
    ForbiddenUser = 'ForbiddenUser'
    ForbiddenUserResource = 'ForbiddenUserResource'
    ForbiddenUserSignupDisabled = 'ForbiddenUserSignupDisabled'
    ForbiddenUserSignupAllowanceExceeded = 'ForbiddenUserSignupAllowanceExceeded'
    ForbiddenUserDoesNotExist = 'ForbiddenUserDoesNotExist'
    ForbiddenUserDisabled = 'ForbiddenUserDisabled'
    ForbiddenUserInsufficientCapability = 'ForbiddenUserInsufficientCapability'
    ForbiddenDRModeEnabled = 'ForbiddenDRModeEnabled'
    ForbiddenInvalid = 'ForbiddenInvalid'
    NotFound = 'NotFound'
    NotFoundProject = 'NotFoundProject'
    NotFoundProjectDefaultIteration = 'NotFoundProjectDefaultIteration'
    NotFoundIteration = 'NotFoundIteration'
    NotFoundIterationPerformance = 'NotFoundIterationPerformance'
    NotFoundTag = 'NotFoundTag'
    NotFoundImage = 'NotFoundImage'
    NotFoundDomain = 'NotFoundDomain'
    NotFoundApimSubscription = 'NotFoundApimSubscription'
    NotFoundInvalid = 'NotFoundInvalid'
    Conflict = 'Conflict'
    ConflictInvalid = 'ConflictInvalid'
    ErrorUnknown = 'ErrorUnknown'
    ErrorIterationCopyFailed = 'ErrorIterationCopyFailed'
    ErrorPreparePerformanceMigrationFailed = 'ErrorPreparePerformanceMigrationFailed'
    ErrorProjectInvalidWorkspace = 'ErrorProjectInvalidWorkspace'
    ErrorProjectInvalidPipelineConfiguration = (
        'ErrorProjectInvalidPipelineConfiguration'
    )
    ErrorProjectInvalidDomain = 'ErrorProjectInvalidDomain'
    ErrorProjectTrainingRequestFailed = 'ErrorProjectTrainingRequestFailed'
    ErrorProjectImportRequestFailed = 'ErrorProjectImportRequestFailed'
    ErrorProjectExportRequestFailed = 'ErrorProjectExportRequestFailed'
    ErrorFeaturizationServiceUnavailable = 'ErrorFeaturizationServiceUnavailable'
    ErrorFeaturizationQueueTimeout = 'ErrorFeaturizationQueueTimeout'
    ErrorFeaturizationInvalidFeaturizer = 'ErrorFeaturizationInvalidFeaturizer'
    ErrorFeaturizationAugmentationUnavailable = (
        'ErrorFeaturizationAugmentationUnavailable'
    )
    ErrorFeaturizationUnrecognizedJob = 'ErrorFeaturizationUnrecognizedJob'
    ErrorFeaturizationAugmentationError = 'ErrorFeaturizationAugmentationError'
    ErrorExporterInvalidPlatform = 'ErrorExporterInvalidPlatform'
    ErrorExporterInvalidFeaturizer = 'ErrorExporterInvalidFeaturizer'
    ErrorExporterInvalidClassifier = 'ErrorExporterInvalidClassifier'
    ErrorPredictionServiceUnavailable = 'ErrorPredictionServiceUnavailable'
    ErrorPredictionModelNotFound = 'ErrorPredictionModelNotFound'
    ErrorPredictionModelNotCached = 'ErrorPredictionModelNotCached'
    ErrorPrediction = 'ErrorPrediction'
    ErrorPredictionStorage = 'ErrorPredictionStorage'
    ErrorRegionProposal = 'ErrorRegionProposal'
    ErrorInvalid = 'ErrorInvalid'


class CustomVisionError(BaseModel):
    code: Code = Field(..., description='The error code.')
    message: str = Field(
        ..., description='A message explaining the error reported by the service.'
    )


class Type(Enum):
    Classification = 'Classification'
    ObjectDetection = 'ObjectDetection'


class Domain(BaseModel):
    enabled: Optional[bool] = None
    exportable: Optional[bool] = None
    id: Optional[UUID] = None
    name: Optional[str] = None
    type: Optional[Type] = None


class Flavor(Enum):
    Linux = 'Linux'
    Windows = 'Windows'
    ONNX10 = 'ONNX10'
    ONNX12 = 'ONNX12'
    ARM = 'ARM'
    TensorFlowNormal = 'TensorFlowNormal'
    TensorFlowLite = 'TensorFlowLite'


class Platform(Enum):
    CoreML = 'CoreML'
    TensorFlow = 'TensorFlow'
    DockerFile = 'DockerFile'
    ONNX = 'ONNX'
    VAIDK = 'VAIDK'


class Status(Enum):
    Exporting = 'Exporting'
    Failed = 'Failed'
    Done = 'Done'


class Export(BaseModel):
    downloadUri: Optional[str] = Field(
        None, description='URI used to download the model.'
    )
    flavor: Optional[Flavor] = Field(
        None,
        description='Flavor of the export. These are specializations of the export platform.\r\nDocker platform has valid flavors: Linux, Windows, ARM.\r\nTensorflow platform has valid flavors: TensorFlowNormal, TensorFlowLite.\r\nONNX platform has valid flavors: ONNX10, ONNX12.',
    )
    newerVersionAvailable: Optional[bool] = Field(
        None,
        description='Indicates an updated version of the export package is available and should be re-exported for the latest changes.',
    )
    platform: Optional[Platform] = Field(None, description='Platform of the export.')
    status: Optional[Status] = Field(None, description='Status of the export.')


class Status1(Enum):
    OK = 'OK'
    OKDuplicate = 'OKDuplicate'
    ErrorSource = 'ErrorSource'
    ErrorImageFormat = 'ErrorImageFormat'
    ErrorImageSize = 'ErrorImageSize'
    ErrorStorage = 'ErrorStorage'
    ErrorLimitExceed = 'ErrorLimitExceed'
    ErrorTagLimitExceed = 'ErrorTagLimitExceed'
    ErrorRegionLimitExceed = 'ErrorRegionLimitExceed'
    ErrorUnknown = 'ErrorUnknown'
    ErrorNegativeAndRegularTagOnSameImage = 'ErrorNegativeAndRegularTagOnSameImage'


class ImageProcessingSettings(BaseModel):
    augmentationMethods: Optional[Dict[str, bool]] = Field(
        None,
        description='Gets or sets enabled image transforms. The key corresponds to the transform name. If value is set to true, then correspondent transform is enabled. Otherwise this transform will not be used.\r\nAugmentation will be uniformly distributed among enabled transforms.',
    )


class ImageRegion(BaseModel):
    created: Optional[datetime] = None
    height: float = Field(..., description='Height.')
    left: float = Field(..., description='Coordinate of the left boundary.')
    regionId: Optional[UUID] = None
    tagId: UUID = Field(..., description='Id of the tag associated with this region.')
    tagName: Optional[str] = None
    top: float = Field(..., description='Coordinate of the top boundary.')
    width: float = Field(..., description='Width.')


class ImageRegionCreateEntry(BaseModel):
    height: float = Field(..., description='Height.')
    imageId: UUID = Field(..., description='Id of the image.')
    left: float = Field(..., description='Coordinate of the left boundary.')
    tagId: UUID = Field(..., description='Id of the tag associated with this region.')
    top: float = Field(..., description='Coordinate of the top boundary.')
    width: float = Field(..., description='Width.')


class ImageRegionCreateResult(BaseModel):
    created: Optional[datetime] = None
    height: float = Field(..., description='Height.')
    imageId: Optional[UUID] = None
    left: float = Field(..., description='Coordinate of the left boundary.')
    regionId: Optional[UUID] = None
    tagId: UUID = Field(..., description='Id of the tag associated with this region.')
    tagName: Optional[str] = None
    top: float = Field(..., description='Coordinate of the top boundary.')
    width: float = Field(..., description='Width.')


class ImageRegionCreateSummary(BaseModel):
    created: Optional[List[ImageRegionCreateResult]] = None
    duplicated: Optional[List[ImageRegionCreateEntry]] = None
    exceeded: Optional[List[ImageRegionCreateEntry]] = None


class ImageTag(BaseModel):
    created: Optional[datetime] = None
    tagId: Optional[UUID] = None
    tagName: Optional[str] = None


class ImageTagCreateEntry(BaseModel):
    imageId: Optional[UUID] = Field(None, description='Id of the image.')
    tagId: Optional[UUID] = Field(None, description='Id of the tag.')


class ImageTagCreateSummary(BaseModel):
    created: Optional[List[ImageTagCreateEntry]] = None
    duplicated: Optional[List[ImageTagCreateEntry]] = None
    exceeded: Optional[List[ImageTagCreateEntry]] = None


class ImageUrl(BaseModel):
    url: str = Field(..., description='Url of the image.')


class ClassificationType(Enum):
    Multiclass = 'Multiclass'
    Multilabel = 'Multilabel'


class ExportableToEnum(Enum):
    CoreML = 'CoreML'
    TensorFlow = 'TensorFlow'
    DockerFile = 'DockerFile'
    ONNX = 'ONNX'
    VAIDK = 'VAIDK'


class TrainingType(Enum):
    Regular = 'Regular'
    Advanced = 'Advanced'


class Iteration(BaseModel):
    classificationType: Optional[ClassificationType] = Field(
        None, description='Gets the classification type of the project.'
    )
    created: Optional[datetime] = Field(
        None, description='Gets the time this iteration was completed.'
    )
    domainId: Optional[UUID] = Field(
        None,
        description='Get or sets a guid of the domain the iteration has been trained on.',
    )
    exportable: Optional[bool] = Field(
        None,
        description='Whether the iteration can be exported to another format for download.',
    )
    exportableTo: Optional[List[ExportableToEnum]] = Field(
        None, description='A set of platforms this iteration can export to.'
    )
    id: Optional[UUID] = Field(None, description='Gets the id of the iteration.')
    lastModified: Optional[datetime] = Field(
        None, description='Gets the time this iteration was last modified.'
    )
    name: str = Field(..., description='Gets or sets the name of the iteration.')
    originalPublishResourceId: Optional[str] = Field(
        None,
        description='Resource Provider Id this iteration was originally published to.',
    )
    projectId: Optional[UUID] = Field(
        None, description='Gets the project id of the iteration.'
    )
    publishName: Optional[str] = Field(None, description='Name of the published model.')
    reservedBudgetInHours: Optional[int] = Field(
        None,
        description='Gets the reserved advanced training budget for the iteration.',
    )
    status: Optional[str] = Field(
        None, description='Gets the current iteration status.'
    )
    trainedAt: Optional[datetime] = Field(
        None, description='Gets the time this iteration was last modified.'
    )
    trainingTimeInMinutes: Optional[int] = Field(
        None, description='Gets the training time for the iteration.'
    )
    trainingType: Optional[TrainingType] = Field(
        None, description='Gets the training type of the iteration.'
    )


class Prediction(BaseModel):
    boundingBox: Optional[BoundingBox] = None
    probability: Optional[float] = Field(None, description='Probability of the tag.')
    tagId: Optional[UUID] = Field(None, description='Id of the predicted tag.')
    tagName: Optional[str] = Field(None, description='Name of the predicted tag.')


class PredictionQueryTag(BaseModel):
    id: Optional[UUID] = None
    maxThreshold: Optional[float] = None
    minThreshold: Optional[float] = None


class OrderBy(Enum):
    Newest = 'Newest'
    Oldest = 'Oldest'
    Suggested = 'Suggested'


class PredictionQueryToken(BaseModel):
    application: Optional[str] = None
    continuation: Optional[str] = None
    endTime: Optional[datetime] = None
    iterationId: Optional[UUID] = None
    maxCount: Optional[int] = None
    orderBy: Optional[OrderBy] = None
    session: Optional[str] = None
    startTime: Optional[datetime] = None
    tags: Optional[List[PredictionQueryTag]] = None


class Status2(Enum):
    Succeeded = 'Succeeded'
    Importing = 'Importing'
    Failed = 'Failed'


class ProjectExport(BaseModel):
    estimatedImportTimeInMS: Optional[int] = Field(
        None,
        description='Estimated time this project will take to import, can change based on network connectivity and load between\r\nsource and destination regions.',
    )
    imageCount: Optional[int] = Field(
        None, description='Count of images that will be exported.'
    )
    iterationCount: Optional[int] = Field(
        None, description='Count of iterations that will be exported.'
    )
    regionCount: Optional[int] = Field(
        None, description='Count of regions that will be exported.'
    )
    tagCount: Optional[int] = Field(
        None, description='Count of tags that will be exported.'
    )
    token: Optional[str] = Field(
        None,
        description='Opaque token that should be passed to ImportProject to perform the import. This token grants access to import this\r\nproject to all that have the token.',
    )


class TargetExportPlatform(Enum):
    CoreML = 'CoreML'
    TensorFlow = 'TensorFlow'
    DockerFile = 'DockerFile'
    ONNX = 'ONNX'
    VAIDK = 'VAIDK'


class ProjectSettings(BaseModel):
    classificationType: Optional[ClassificationType] = Field(
        None, description='Gets or sets the classification type of the project.'
    )
    detectionParameters: Optional[str] = Field(
        None, description='Detection parameters in use, if any.'
    )
    domainId: Optional[UUID] = Field(
        None, description='Gets or sets the id of the Domain to use with this project.'
    )
    imageProcessingSettings: Optional[ImageProcessingSettings] = None
    targetExportPlatforms: Optional[List[TargetExportPlatform]] = Field(
        None,
        description='A list of ExportPlatform that the trained model should be able to support.',
    )
    useNegativeSet: Optional[bool] = Field(
        None, description='Indicates if negative set is being used.'
    )


class Region(BaseModel):
    height: float = Field(..., description='Height.')
    left: float = Field(..., description='Coordinate of the left boundary.')
    tagId: UUID = Field(..., description='Id of the tag associated with this region.')
    top: float = Field(..., description='Coordinate of the top boundary.')
    width: float = Field(..., description='Width.')


class RegionProposal(BaseModel):
    boundingBox: Optional[BoundingBox] = None
    confidence: Optional[float] = None


class StoredImagePrediction(BaseModel):
    created: Optional[datetime] = Field(
        None, description='Date this prediction was created.'
    )
    domain: Optional[UUID] = Field(None, description='Domain used for the prediction.')
    id: Optional[UUID] = Field(None, description='Prediction Id.')
    iteration: Optional[UUID] = Field(None, description='Iteration Id.')
    originalImageUri: Optional[str] = Field(
        None, description='The URI to the original prediction image.'
    )
    predictions: Optional[List[Prediction]] = Field(
        None, description='List of predictions.'
    )
    project: Optional[UUID] = Field(None, description='Project Id.')
    resizedImageUri: Optional[str] = Field(
        None, description='The URI to the (resized) prediction image.'
    )
    thumbnailUri: Optional[str] = Field(
        None, description='The URI to the thumbnail of the original prediction image.'
    )


class StoredSuggestedTagAndRegion(BaseModel):
    created: Optional[datetime] = Field(
        None, description='Date this prediction was created.'
    )
    domain: Optional[UUID] = Field(None, description='Domain used for the prediction.')
    height: Optional[int] = Field(None, description='Height of the resized image.')
    id: Optional[UUID] = Field(None, description='Prediction Id.')
    iteration: Optional[UUID] = Field(None, description='Iteration Id.')
    originalImageUri: Optional[str] = Field(
        None, description='The URI to the original prediction image.'
    )
    predictionUncertainty: Optional[float] = Field(
        None,
        description='Uncertainty (entropy) of suggested tags or regions per image.',
    )
    predictions: Optional[List[Prediction]] = Field(
        None, description='List of predictions.'
    )
    project: Optional[UUID] = Field(None, description='Project Id.')
    resizedImageUri: Optional[str] = Field(
        None, description='The URI to the (resized) prediction image.'
    )
    thumbnailUri: Optional[str] = Field(
        None, description='The URI to the thumbnail of the original prediction image.'
    )
    width: Optional[int] = Field(None, description='Width of the resized image.')


class SuggestedTagAndRegion(BaseModel):
    created: Optional[datetime] = Field(
        None, description='Date this prediction was created.'
    )
    id: Optional[UUID] = Field(None, description='Prediction Id.')
    iteration: Optional[UUID] = Field(None, description='Iteration Id.')
    predictionUncertainty: Optional[float] = Field(
        None,
        description='Uncertainty (entropy) of suggested tags or regions per image.',
    )
    predictions: Optional[List[Prediction]] = Field(
        None, description='List of predictions.'
    )
    project: Optional[UUID] = Field(None, description='Project Id.')


class SortBy(Enum):
    UncertaintyAscending = 'UncertaintyAscending'
    UncertaintyDescending = 'UncertaintyDescending'


class SuggestedTagAndRegionQueryToken(BaseModel):
    continuation: Optional[str] = Field(
        None,
        description='Continuation Id for database pagination. Initially null but later used to paginate.',
    )
    maxCount: Optional[int] = Field(
        None,
        description='Maximum number of results you want to be returned in the response.',
    )
    session: Optional[str] = Field(
        None,
        description='SessionId for database query. Initially set to null but later used to paginate.',
    )
    sortBy: Optional[SortBy] = Field(
        None, description='OrderBy. Ordering mechanism for your results.'
    )
    tagIds: Optional[List[UUID]] = Field(
        None, description='Existing TagIds in project to filter suggested tags on.'
    )
    threshold: Optional[float] = Field(
        None, description='Confidence threshold to filter suggested tags on.'
    )


class Type1(Enum):
    Regular = 'Regular'
    Negative = 'Negative'


class Tag(BaseModel):
    description: str = Field(
        ..., description='Gets or sets the description of the tag.'
    )
    id: Optional[UUID] = Field(None, description='Gets the Tag ID.')
    imageCount: Optional[int] = Field(
        None, description='Gets the number of images with this tag.'
    )
    name: str = Field(..., description='Gets or sets the name of the tag.')
    type: Type1 = Field(..., description='Gets or sets the type of the tag.')


class TagFilter(BaseModel):
    tagIds: Optional[List[UUID]] = Field(
        None, description='Existing TagIds in project to get suggested tags count for.'
    )
    threshold: Optional[float] = Field(
        None, description='Confidence threshold to filter suggested tags on.'
    )


class TagPerformance(BaseModel):
    averagePrecision: Optional[float] = Field(
        None, description='Gets the average precision when applicable.'
    )
    id: Optional[UUID] = None
    name: Optional[str] = None
    precision: Optional[float] = Field(None, description='Gets the precision.')
    precisionStdDeviation: Optional[float] = Field(
        None, description='Gets the standard deviation for the precision.'
    )
    recall: Optional[float] = Field(None, description='Gets the recall.')
    recallStdDeviation: Optional[float] = Field(
        None, description='Gets the standard deviation for the recall.'
    )


class TrainingParameters(BaseModel):
    selectedTags: Optional[List[UUID]] = Field(
        None,
        description='List of tags selected for this training session, other tags in the project will be ignored.',
    )


class DomainsGetResponse(RootModel[List[Domain]]):
    root: List[Domain]


class TargetExportPlatforms(RootModel[List[TargetExportPlatform]]):
    root: List[TargetExportPlatform]


class ImageIds(RootModel[List[UUID]]):
    root: List[UUID] = Field(..., max_length=256, min_length=0)


class ProjectsProjectIdImagesPostRequest(BaseModel):
    imageData: bytes = Field(
        ...,
        description='Binary image data. Supported formats are JPEG, GIF, PNG, and BMP. Supports images up to 6MB.',
    )


class TagIds(RootModel[List[UUID]]):
    root: List[UUID] = Field(..., max_length=20, min_length=0)


class RegionIds(RootModel[List[UUID]]):
    root: List[UUID] = Field(..., max_length=64, min_length=0)


class ProjectsProjectIdImagesSuggestedCountPostResponse(
    RootModel[Optional[Dict[str, int]]]
):
    root: Optional[Dict[str, int]] = None


class OrderBy1(Enum):
    Newest = 'Newest'
    Oldest = 'Oldest'


class TagIds2(RootModel[List[UUID]]):
    root: List[UUID]


class ImageIds2(RootModel[List[UUID]]):
    root: List[UUID] = Field(..., max_length=64, min_length=0)


class TagIds3(RootModel[List[UUID]]):
    root: List[UUID] = Field(..., max_length=20, min_length=0)


class ProjectsProjectIdIterationsGetResponse(RootModel[List[Iteration]]):
    root: List[Iteration]


class ProjectsProjectIdIterationsIterationIdExportGetResponse(RootModel[List[Export]]):
    root: List[Export]


class TagIds5(RootModel[List[UUID]]):
    root: List[UUID]


class Ids(RootModel[List[UUID]]):
    root: List[UUID] = Field(..., max_length=64, min_length=0)


class ProjectsProjectIdQuicktestImagePostRequest(BaseModel):
    imageData: bytes = Field(
        ...,
        description='Binary image data. Supported formats are JPEG, GIF, PNG, and BMP. Supports images up to 6MB.',
    )


class ProjectsProjectIdTagsGetResponse(RootModel[List[Tag]]):
    root: List[Tag]


class ProjectsProjectIdTagsandregionsSuggestionsPostResponse(
    RootModel[List[SuggestedTagAndRegion]]
):
    root: List[SuggestedTagAndRegion]


class Image(BaseModel):
    created: Optional[datetime] = Field(None, description='Date the image was created.')
    height: Optional[int] = Field(None, description='Height of the image.')
    id: Optional[UUID] = Field(None, description='Id of the image.')
    originalImageUri: Optional[str] = Field(
        None, description='The URI to the original uploaded image.'
    )
    regions: Optional[List[ImageRegion]] = Field(
        None, description='Regions associated with this image.'
    )
    resizedImageUri: Optional[str] = Field(
        None, description='The URI to the (resized) image used for training.'
    )
    tags: Optional[List[ImageTag]] = Field(
        None, description='Tags associated with this image.'
    )
    thumbnailUri: Optional[str] = Field(
        None, description='The URI to the thumbnail of the original image.'
    )
    width: Optional[int] = Field(None, description='Width of the image.')


class ImageCreateResult(BaseModel):
    image: Optional[Image] = None
    sourceUrl: Optional[str] = Field(None, description='Source URL of the image.')
    status: Optional[Status1] = Field(None, description='Status of the image creation.')


class ImageCreateSummary(BaseModel):
    images: Optional[List[ImageCreateResult]] = Field(
        None, description='List of the image creation results.'
    )
    isBatchSuccessful: Optional[bool] = Field(
        None,
        description='True if all of the images in the batch were created successfully, otherwise false.',
    )


class ImageFileCreateEntry(BaseModel):
    contents: Optional[str] = None
    name: Optional[str] = None
    regions: Optional[List[Region]] = None
    tagIds: Optional[List[UUID]] = None


class ImageIdCreateEntry(BaseModel):
    id: Optional[UUID] = Field(None, description='Id of the image.')
    regions: Optional[List[Region]] = None
    tagIds: Optional[List[UUID]] = None


class ImagePerformance(BaseModel):
    created: Optional[datetime] = None
    height: Optional[int] = None
    id: Optional[UUID] = None
    imageUri: Optional[str] = None
    predictions: Optional[List[Prediction]] = None
    regions: Optional[List[ImageRegion]] = None
    tags: Optional[List[ImageTag]] = None
    thumbnailUri: Optional[str] = None
    width: Optional[int] = None


class ImagePrediction(BaseModel):
    created: Optional[datetime] = Field(
        None, description='Date this prediction was created.'
    )
    id: Optional[UUID] = Field(None, description='Prediction Id.')
    iteration: Optional[UUID] = Field(None, description='Iteration Id.')
    predictions: Optional[List[Prediction]] = Field(
        None, description='List of predictions.'
    )
    project: Optional[UUID] = Field(None, description='Project Id.')


class ImageRegionCreateBatch(BaseModel):
    regions: Optional[List[ImageRegionCreateEntry]] = None


class ImageRegionProposal(BaseModel):
    imageId: Optional[UUID] = None
    projectId: Optional[UUID] = None
    proposals: Optional[List[RegionProposal]] = None


class ImageTagCreateBatch(BaseModel):
    tags: Optional[List[ImageTagCreateEntry]] = Field(
        None, description='Image Tag entries to include in this batch.'
    )


class ImageUrlCreateEntry(BaseModel):
    regions: Optional[List[Region]] = None
    tagIds: Optional[List[UUID]] = None
    url: str = Field(..., description='Url of the image.')


class IterationPerformance(BaseModel):
    averagePrecision: Optional[float] = Field(
        None, description='Gets the average precision when applicable.'
    )
    perTagPerformance: Optional[List[TagPerformance]] = Field(
        None, description='Gets the per-tag performance details for this iteration.'
    )
    precision: Optional[float] = Field(None, description='Gets the precision.')
    precisionStdDeviation: Optional[float] = Field(
        None, description='Gets the standard deviation for the precision.'
    )
    recall: Optional[float] = Field(None, description='Gets the recall.')
    recallStdDeviation: Optional[float] = Field(
        None, description='Gets the standard deviation for the recall.'
    )


class PredictionQueryResult(BaseModel):
    results: Optional[List[StoredImagePrediction]] = Field(
        None, description='Result of an prediction request.'
    )
    token: Optional[PredictionQueryToken] = None


class Project(BaseModel):
    created: Optional[datetime] = Field(
        None, description='Gets the date this project was created.'
    )
    description: str = Field(
        ..., description='Gets or sets the description of the project.'
    )
    drModeEnabled: Optional[bool] = Field(
        None,
        description='Gets if the Disaster Recovery (DR) mode is on, indicating the project is temporarily read-only.',
    )
    id: Optional[UUID] = Field(None, description='Gets the project id.')
    lastModified: Optional[datetime] = Field(
        None, description='Gets the date this project was last modified.'
    )
    name: str = Field(..., description='Gets or sets the name of the project.')
    settings: ProjectSettings
    status: Optional[Status2] = Field(
        None, description='Gets the status of the project.'
    )
    thumbnailUri: Optional[str] = Field(
        None, description='Gets the thumbnail url representing the image.'
    )


class SuggestedTagAndRegionQuery(BaseModel):
    results: Optional[List[StoredSuggestedTagAndRegion]] = Field(
        None,
        description='Result of a suggested tags and regions request of the untagged image.',
    )
    token: Optional[SuggestedTagAndRegionQueryToken] = None


class ProjectsGetResponse(RootModel[List[Project]]):
    root: List[Project]


class ProjectsProjectIdImagesIdGetResponse(RootModel[List[Image]]):
    root: List[Image]


class ProjectsProjectIdImagesTaggedGetResponse(RootModel[List[Image]]):
    root: List[Image]


class ProjectsProjectIdImagesUntaggedGetResponse(RootModel[List[Image]]):
    root: List[Image]


class ProjectsProjectIdIterationsIterationIdPerformanceImagesGetResponse(
    RootModel[List[ImagePerformance]]
):
    root: List[ImagePerformance]


class ImageFileCreateBatch(BaseModel):
    images: Optional[List[ImageFileCreateEntry]] = None
    tagIds: Optional[List[UUID]] = None


class ImageIdCreateBatch(BaseModel):
    images: Optional[List[ImageIdCreateEntry]] = None
    tagIds: Optional[List[UUID]] = None


class ImageUrlCreateBatch(BaseModel):
    images: Optional[List[ImageUrlCreateEntry]] = None
    tagIds: Optional[List[UUID]] = None
